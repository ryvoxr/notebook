\documentclass[12pt]{article}
\usepackage{natbib}
\usepackage{setspace}
\usepackage{listings, listings-rust}
\usepackage{float}
\usepackage[letterpaper]{geometry}
\geometry{top=1.0in, bottom=1.0in, left=1.0in, right=1.0in}
\usepackage{times}
\usepackage{lineno}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{} 
\chead{} 
\rhead{Oehlrich \thepage} 
\lfoot{} 
\cfoot{} 
\rfoot{} 
\renewcommand{\headrulewidth}{0pt} 
\renewcommand{\footrulewidth}{0pt}
\doublespacing{}
\setlength\headsep{0.333in}

\author{Henry Oehlrich}

\begin{document}
\begin{flushleft}
Henry Oehlrich \\
Mrs. Schmitz \\
H. English 4 \\
15 Mar 2023 \\
\begin{center}
Rust: A Richly Typed, Memory-safe, Algebraic Systems Language for Writing Perfect Code
\end{center}
\setlength{\parindent}{0.5in}

% Intro

Started as a passion project at Mozilla in 2006, Rust has infiltrated the
market as a new, production ready, paradigm shifting language. The Rust team's
devotion to safety and speed has allowed them to reach their three goals:
performance, reliability, and productivity.

% Borrow checker

%% Intro and references
Rust approaches memory management with a new paradigm. It uses neither a
garbage collector nor forces memory management on the programmer; instead it
achieves memory safety using a borrow checker. The borrow checker has two
rules: data has one owner and data may have multiple readers or one writer.
When a piece of non-global data is instantiated, a sized portion of data from
the stack, or a chunk of data in the heap, is allocated to it. The variable
that the data is assigned to is its owner. Passing data by value (IE not
through a pointer) moves the data to the function it was passed into. This data
is gone, it can neither be accessed nor modified by the previous owner. In
order to share data without moving, pass a reference (pointer) to the data.
This is called borrowing. 

%% Variable lifetimes and scope
In order to understand how the borrow checker functions, one must understand
variable lifetimes and scope. When the owner of a value goes out of scope, the
value is dropped. A variable's scope is defined by the narrowest set of curly
braces (this is often called a block). A variable comes into scope when it is
declared and exits scope when program execution exits its block. A variables
lifetime is the length of time it is in scope. The lifetime of the owner of a
value must exceed the lifetime of all references to it. This makes null and
dangling pointers impossible.

%% Code example
\singlespacing{}
\begin{verbatim}
    fn main() {
        // 's' comes into scope as it is declared
        let s: String = String::from("This is a string");

        // Pass 's' by reference
        // 's' still owns the String
        let len: usize = get_len(&s);

        println!("The length of '{}' is {}", s, len);
    }   // This scope is now over and 's' is no longer valid

    fn get_len(rs: &String) -> usize {  // 'rs' is declared here
        rs.len();
    } // 'rs' goes out of scope here and is dropped
\end{verbatim}
\doublespacing{}

%% Mutable references
A mutable reference to a value must be the only reference to that value. This
is to prevent race conditions for reading or modifying data. If another part of
the program tries to read or modify a piece of data that is also being modified
by a mutable reference, a race condition could occur and inconsistent results
would be produced. Rust's imperviousness to race conditions is coined as
"Fearless Concurrency". 

% Type System

%% Intro to type system
Rust is a very strongly typed language. This means that data must have a
defined or inferred type and must conform to stricter compiler rules and
safeties. Rust's type system prevents programmers from making common and
redundant mistakes at compile time (or more realistically linted in the
editor). Every Rust builtin type has several guarantees if it compiles. For
example, the \textit{String} type guarantees that it will always be a valid
UTF-8 encoded (Unicode) vector of bytes that can be displayed. While this seems
trivial, nearly all systems languages and quite a few higher level languages
will allow the programmer to do unsafe or unrepresentable things with strings.

%% Primitives

%% Structs
C-style structs allow Rust programmers to create custom data types that improve
readability, code structure, and safety. Structs can be thought of as a custom
blueprint for a semantically useful datatype. They are type-checked by the
compiler and follow a C-style key-value syntax. Structs are private by default
and cannot be accessed by other files unless defined with the \textit{pub}
keyword.

%% Code example
\singlespacing{}
\begin{verbatim}
use chrono::{Local, DateTime};
use sha256::digest;

// Define the User struct with several fields
struct User {
    username: String,
    email: String,
    password_hash: String,
    last_logon: DateTime<Local>,
    google_uuid: Option<String>,
}

fn main() {
// Construct a user object
let user = User {
    username: String::from("hoehlrich"),
    email: String::from("henry@oehlrich.xyz"),
    password_hash: digest("password123"),
    last_logon: Local::now(),
    google_uuid: None,
};
println!("User '{}' with email '{}' last logged on '{}'.",
    user.username,
    user.email,
    user.last_logon.format("[%Y-%m-%d][%H:%M:%S]")
);
// output:  User 'hoehlrich' with email 'henry@oehlrich.xyz'
//          last logged on '[2023-03-21][09:25:09]'.
}
\end{verbatim}
\doublespacing{}

%% Impl blocks
Unlike other popular languages Rust does not have a higher level of object
abstraction above structs. Struct \textit{impl} (implementation) blocks are
Rust's form of object oriented methods. Everything in the \textit{impl} block
will be associated with the attached struct. Functions defined in
implementation blocks that operate on objects are called methods. Methods may
take any form or reference of \textit{self} as the first parameter;
\textit{self} is the object instance that the method is begin called on.

%% Enums
Enums, or enumerations, allow the programmer to define a type that can be one
of a set of values. An enum of colors might include red, blue, yellow, etc; an
instance of the colors enum might be red. Enumerations allow a single type to
have multiple variants. This is syntactically demonstrated with the double
colon namespacing after the identifier. Functions that take an enum can take
any variant of that type. Enum variants are also able to hold data.

%% Code example
\singlespacing{}
\begin{verbatim}
// Define the Event enum
enum Event {
    LeftClick(i32, i32),    // LeftClick has x and y pos
    RightClick(i32, i32),   // RightClick has x and y pos
    KeyPress(char),       // Key press stores the key pressed
    Quit,               // Quit does not need to store data
}

fn main() {
    let k_key = KesPress('k');
}
\end{verbatim}
\doublespacing{}

%% Pattern matching
In order to add different functionality to different variants of enums, Rust
allows the programmer to match patterns on enums. This is similar to the C or
Java switch statement. \textit{\cite{the-c-programming-language}}. It is much safer than
either of these languages implementations, though; in Rust you must handle each
and every possible control flow path when matching on enums (even if the
handling crashes the program, it must be explicitly stated). Pattern matching
can extract and handle the data that may (or may not) be held in an enum
instance.

%% Option
Rust has no nulls. In order to represent the value of none, Rust uses the
\textit{Option} enum. The \textit{Option} enum is defined in the standard
library. \textit{Option} is either a value \textit{Some(v)}, or \textit{None}.
Functions that may or may not return a value should return that value (or lack
thereof) as an Option. The calling portion of the function can then match on
that enum, storing the data if it is valid or proceeding as necessary if the
data doesn't exist.

%% Code example
\singlespacing{}
\begin{verbatim}
// Print google_uuid if it exists, if not give a message
// Remember from a previous example that google_uuid is an Option<String>
match user.google_uuid {
    Some(v) => println!("google uuid: {}", v),
    None => println!("user does not have a google uuid"),
}
\end{verbatim}
\doublespacing{}

%% Result
Perhaps the most useful and paradigm shifting enum is the standard library's
\textit{Result} enum. The \textit{Result} type is Rust's answer to error
handling. It can either hold a value (\textit{Ok(v)}), or an error
(\textit{Err(e))}. In order to access the value (or error) contained in the
Result, it must be explicitly handled with a match statement or a temporary call
to unwrap. Errors in results do not interrupt the program control flow as is
done with other popular languages; instead, idiomatic Rust programs will propagate
any errors up the stack to be dealt with.

%% ? Operator
A common pattern with \textit{Result} types is to match on the wrapped type
assigning the value to a variable and returning the error if it exists. This
pattern is so common that the Rust Team assigned it to the \textit{?} operator.
At compile time, any uses of \textit{?} will be automatically expanded to the
long-form match statements; this is similar, but not the same, as macro
expansions.

\singlespacing{}
\begin{verbatim}
fn read_data() -> Result<String, Box<dyn Error>> {
    // Expanded version of error handling
    let data = match fs::read_to_string("file.txt") {
        Ok(v) => v,
        Err(e) => return Err(Box::new(e)),
    };

    // This is the same as above
    let data_ = fs::read_to_string("file.txt")?;

    // Return the data if there hasn't been an error
    return Ok(data);
}
\end{verbatim}
\doublespacing{}

%% Generics
Generics in Rust are placeholders for concrete types. The previously discussed
enums \textit{Option} and \textit{Result} are both generics. Using generics
allows functions, methods, structs, and enums to take multiple possible types
without code duplication. Each generic type (specified in angle brackets after
the function or struct name) is represented by a letter (commonly T and U).
Generic identifiers may be reused in order to specify that two
parameters/attributes share the same type. Similarly to the \textit{?}
operator, generics do not decrease code performance. In the monomorphization
step of compilation, the compiler expands all generics into variants required
by the code.

\singlespacing{}
\begin{verbatim}
fn main() {
    // p1 is defined with coords as two i32s
    let p1 = Point { x: 1, y: 2 };
    // p2 is defined with coords as two f32s
    let p2 = Point { x: 0.34, y: 123.21 };
}

// Struct Point is defined with two attributes of generic type T
struct Point<T> {
    x: T,
    y: T,
}
\end{verbatim}
\doublespacing{}

%% Traits
Traits define behavior that can be implemented on multiple types (they are
similar to interfaces in other popular languages.) A trait includes a set of
function signatures that all types that implement the trait must also
implement. Traits can include default implementations that are injected into
types that implement the trait but do not override the default function by
reimplementing it.

\singlespacing{}
\begin{verbatim}
// Every type that implements HasSize must implement the associated methods
trait HasSize {
    fn get_len(&self) -> usize;

    fn allocated_size(&self) -> usize;
}

struct Sentence {
    text: String,
    author: String,
}

impl HasSize for Sentence {
    fn get_len(&self) -> usize {
        return self.text.len();
    }

    fn allocated_size(&self) -> usize {
        return self.text.capacity();
    }
}

fn main() {
    let sentence = Sentence {
        text: String::from("Almost done with the rough draft"),
        author: String::from("Henry Oehlrich"),
    };

    println!(
        "Sentence with len {} and allocaed size {}",
        sentence.get_len(),
        sentence.allocated_size(),
    )
}
\end{verbatim}
\doublespacing{}

%% Trait bounds
Trait bounds allow the programmer to specify the limits or bounds to generic
types. In the context of functions, the programmer can specify trait bounds on
types by assigning traits to a generic type and then use the resulting generic
to specify the type of parameters. This generic form of parameter types allows
for functions to take any type that meets the specified requirements.

%% Where and impl clauses
Because each generic type must have its own trait bounds, function signatures
can get cluttered when multiple generics are involved. Rust has the
\textit{where} clause sugar syntax in order to combat this problem. The where
clause adds trait bounds on previously declared generic types. In cases where a
generic is only used once, Rust allows for the standard type annotation to
contain an \textit{impl trait} portion.

\singlespacing{}
\begin{verbatim}
// Add the lengths of two sized lengthfull objects
// Notice the generic declared in the signature
fn add_lens<T: Sized + ExactSizeIterator>(size1: &T, size2: &T) -> usize {
    size1.len() + size2.len()
}

// Print person's info in a generic way
// Generics declared using the where clause
fn print_info<T, U>(name: &T, age: &U)
where
    T: std::fmt::Display,
    U: num::Integer + std::fmt::Display,
{
    println!("{} is {} years old!", name, age);
}
\end{verbatim}
\doublespacing{}

\cite{rustforrustaceans} \\
\cite{rust-lang.org} \\
\cite{rust-by-example} \\
\cite{the-c-programming-language} \\
\cite{noboilerplate}

\bibliographystyle{mla}
\bibliography{refs} 

\end{flushleft}
\end{document}
