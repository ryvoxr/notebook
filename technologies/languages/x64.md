# x64 Programming

x64 is a generic nave for 64-bit extensions to the x86 instruction set
architecture (ISA)
- AMD introduced x86-64 later renamed AMD64
- Intel named their implementation IA-32e and then EMT64

## Architecture

### General Architecture

Data sizes:
- byte -> 8 bits
- word -> 16 bits
- double word -> 32 bits
- quadword -> 64 bits
- double quadword -> 128 bits

Stores bytes "little endian"
- Lower significant bytes are stored in lower memory adresses

General purpose 64-bit registers (GPRs)
1. RAX
2. RBX
3. RCX
4. RDX
5. RBP
6. RSI
7. RDI
8. RSP
9. R8
10. R9
11. R10
12. R11
13. R12
14. R13
15. R14
16. R15

Can access lower bits of the first 8 registers by using different names
- Replacing the 'R' with 'E' accesses the lower 32 bits
- Removing the 'R' accesses the lower 16 bits
- Removing the 'R' and replacing 'X' with an 'L' accesses the lower byte of the
  lower 16 bits
- Removing the 'R' and replacing 'X' with an 'H' accesses the higher byte of
  the lower 16 bits

R8 to R15 can be accessed in a similar manner
- R8 (qword)
- R8D (lower dword)
- R8W (lowest word)
- R8B (lowest byte)

The 64 bit instruction pointer RIP points to the next instruction to be executed
- Supports a 64-bit flat memory model

RSP points to the last item pushed onto the stack
- Grows toward lower addresses
- The stack is used to store return dresses for subroutines and for storing
  "shadow space"

The RFLAGS register stores flags used for results of operations and for
controlling the processor
- Formed from the x86 320bit register EFLAGS by adding a higher 32 bits which
  are reserved and currently unused

The floating point unit (FPU)
- Contains eight registers: FPR0-FPR7
- Status and control registers
- A few other specialized registers

Binary Coded Decimal (BCD) is supported by a few 8-bit instructions

### SIMD Architecture

Single Instruction Multiple Data -> SIMD
- execute a single command on multiple pieces of data in parallel
- Are a common usage for assembly routines

MMX and SSE commands (using the MMX and XMM registers) support SIMD operations
- Eight bytes can be added to eight bytes in one instruction using MMX

The eight 64-bit MMX registers MMX0-MMX7 are aliased on top of FPR0-FPR7
- Any code mixing FP and MMX operations must be careful not to overwrite required values

## Tools

### Assemblers

Netwide Assembler -> NASM
NASM rewrite -> YASM
Flat Assembler -> FASM
Microsoft Assembler -> MASM

## Instruction Basics

### Addressing Modes

Addressing modes are ways an instruction can access registers or memory

Immediate
- The value is stored in the instruction
- `ADD EAX, 14 ; add 14 into 32-bit EAX`

Register to register
- `ADD R8L, AL ; add 8 bit AL into R8l`

Indirect
- Allows for using an 8, 16, or 32 bit displacement, any GPRs for base and
  index, and a scale of 1, 2, 4, or 8 to multiply the index
- `MOV R8W, 1234[8*RAX+RCX] ; move word at adress 8*RAX+RCX+1234`

RIP-relative addressing
- Allows accessing data tables in the code relative to the current instruction pointer
- Making position independent code easier to implement
- `MOV AL, [RIP] ; RIP points to the next instruction`
- `NOP`
